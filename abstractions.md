Для начала рассмотрим некоторые базовые идеи программирования, которые часто отождествляют с ООП \(что бы это ни значило\). Некоторые из этих идей существовали не только задолго до появления термина ООП, но и задолго до появления компьютеров как таковых.

### Абстракция

В ~~далекой далекой галактике~~ древности, у людей не существовало цифр отдельно от вещей. Два оленя или две палки обозначались отдельными словами и знаками. Так продолжалось до тех пор, пока кто-то не увидел, что можно выделить понятия "два", "три", "десять" и начать применять их ко всем перечислимым предметам. Так появилась абстракция "числа". Мы настолько привыкли к этому, что даже не задумываемся над их абстрактностью, а вот для древнего человека это был прорыв.

В наших программах, вообще, все с чем мы работаем - это абстракция. Более того, я возьмусь утверждать, что большая часть задач, которые решаются с помощью программирования, сводится к тому, чтобы создавать и использовать правильные абстракции. Под словом "правильные" я, ни в коем случае не имею в виду "много". Думаю, здесь собрались взрослые люди, которым не надо объяснять что мир не черный и белый, а во всем хороша золотая середина.

Перейдем от абстрактных рассуждений к конкретным примерам. Самое простое, что можно придумать, это функция.

#### Абстракция с помощью функций

Попробуйте с трех раз угадать, что происходит в этом коде:

```javascript
const a = 5;
const b = 10;
const result = a * b;
```

Вероятно, вы ответите, что это умножение двух чисел, но я туда заложил другой смысл, а именно нахождение площади прямоугольника. И если в данной ситуации, об этом можно было бы догадаться, назови я переменную `result` именем `area` , то в более сложных ситуациях \(даже в этой, но внутри большого блока кода\) шансов просто нет.

Очевидно, что можно реализовать функцию и сделать код таким:

```javascript
const a = 5;
const b = 10;
const area = getRectangleArea(a, b);
```

Обратите внимание на важнейшую идею абстракции. Первостепенно не сокращение дублирования кода, а создание кода, который выражает ваши мысли прямо. Если нам нужно найти площадь прямоугольника, то именно это мы и делаем в коде. В 2013 году, я придумал специальный термин "[ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)" с таким определением:

> Ментальное программирование это написание такого кода, читая который, можно восстановить исходную задачу в первоначальных терминах

Функция как абстракция довольно понятная вещь, особенно приятно если она чистая. А что насчет данных?

#### Абстракция с помощью Данных

Чтобы не ходить далеко, разберем пример используемый в курсе на хекслете. Опишем код, который позволяет работать с отрезками на координатной плоскости.

```javascript
const segment1 = [1, 10, 5, 2];
const segment2 = [-5, 0, 9, 10];
const startPoint1 = getStartPoint(segment1); // [1, 10]
const crossed = hasIntersection(segment1, segment2);
const rotatedSegment = rotate(10, segment1);
```

В этом коде видно применение функций, что резко облегчает его понимание и это хорошо, но кое-что по прежнему очень плохо. Структура отрезка торчит наружу, следовательно если захочется поменять реализацию, то придется найти все места где создаются сегменты и переписать их. В примере выше, скорее всего, захочется изменить структуру на подобную: `[[1, 10], [5, 2]]` . То есть здесь мы видим явное выделение понятия "точка". В свою очередь, для точек можно ввести собственную абстракцию, что упростит реализацию функций сегментов, так как они будут опираться на функции для работы с точками. Эта концепция носит название "барьеры абстракции".

Так как же правильно создавать сегменты? И снова нам помогают функции:

```javascript
const segment1 = makeSegment(1, 10, 5, 2);
// Вариант с точками
const segment2 = makeSegmentWithPoints(makePoint(1, 10), makePoint(5, 2));
```

У нас есть конструктор `makeSegment` , так же у нас есть селекторы \(геттеры\) `getStartPoint` и `getFinishPoint`. Напоминает что-нибудь? Получилось что мы реализовали, нами придуманный, [АТД](https://ru.wikipedia.org/wiki/Абстрактный_тип_данных).

Возникает закономерный вопрос, а что будет если кто-то напрямую поправит данные, в обход интерфейсных функций?

Справедливости ради, в любом языке, при желании, можно обойти ограничения абстракции \(чем бы она ни была выражена\) и, в реальности, это не такая огромная проблема как многим кажется. Не в том смысле, что не нужно соблюдать инварианты, их соблюдать как раз таки нужно, а в том, что если у вас есть интерфейс и до него легко добраться, никто не будет идти в обход. Но демонстрации ради, я покажу то как можно добиться по-настоящему серьезной инкапсуляции:

```javascript
// Определения

const makeSegment = (point1, point2) => (message) => {
  switch (message) {
    case 'getStartPoint':
      return point1;
    case 'getFinishPoint':
      return point2;
    default:
      // some handling
  }
};

const getStartPoint = segment => segment('getStartPoint');

// Использование

const segment = makeSegment(makePoint(1, 10), makePoint(5, 2));
console.log(getStartPoint(segment)); // [1, 10]
```

Вероятно, для многих \(кто не учится на хекслете, хехе\) этот код выглядит шокирующе, хотя, в реальности, здесь используется только свойство замыкания и наши данные представлены функциями \(!!!\). Поэкспериментируйте на [repl.it](https://repl.it/languages/javascript) чтобы хорошо разобраться в этом коде.

Теперь, добраться до кишок можно только с помощью посылки сообщения. Напрямую воздействовать на составные части нашего сегмента просто невозможно. Причем для этого не использовались специализированные средства, все получилось на одних функциях.

Итого мы получили хорошо защищенную абстракцию, которую легко расширять и которой легко пользоваться. Она моделирует заданную предметную область и говорим мы о сегментах в терминах сегментов, а не концепций языков программирования.

Выше я написал, что в коде используется "посылка сообщений", но не дал объяснения. Исправляюсь. Как правило, в языках, вызов конкретной функции это прерогатива языка, если функция определена, то она будет вызвана, если нет, то возникнет ошибка. В случае с посылкой сообщения, ответственность за реакцию ложится на приемник. Технически, есть разные способы реализации, один из которых показан выше. Функция принимает на вход строчку-сообщение, и внутри, на основе конструкции `switch` решает как отреагировать. Важно то, что можно определить какое-то дефолтное поведение, более того, можно строить динамические сообщения и, даже, менять состав ожидаемых сообщений после ответа на предыдущее. Но не все языки предоставляют такую возможность, например в java нет посылки сообщений \(но можно эмулировать используя reflection\), в php и ruby есть, а в js они реализуются с помощью механизма `Proxy`.

Как видите ООП нет \(а может есть? ;\), а многие идеи, которые постоянно приписывают этому трехбуквию - есть.

---

### Вопросы на самопроверку

Что означает фраза применительно к ОС семейства \*NIX:

> Все есть файл



